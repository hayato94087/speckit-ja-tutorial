---
description: 現在の機能仕様の未指定領域を特定し、最大5つの高度にターゲットを絞った明確化質問を行い、回答を仕様にエンコードします。
handoffs: 
  - label: speckit.plan
    agent: speckit.plan
    prompt: 仕様の計画を作成します。使用技術は...
  - label: speckit.checklist
    agent: speckit.checklist
    prompt: UXの観点でチェックリストを作成してください。
---

## ユーザー入力

```text
$ARGUMENTS
```

続行する前に、ユーザー入力を考慮する**必要があります**（空でない場合）。

## 概要

目標: アクティブな機能仕様の曖昧さや欠落している決定ポイントを検出・削減し、明確化を仕様ファイルに直接記録します。

注意: この明確化ワークフローは `/speckit.plan` を呼び出す前に実行（および完了）されることが想定されています。ユーザーが明確化をスキップすると明示的に述べた場合（例: 探索的スパイク）、続行しても構いませんが、下流での手戻りリスクが増加することを警告する必要があります。

実行ステップ:

1. リポジトリルートから `.specify/scripts/bash/check-prerequisites.sh --json --paths-only` を**1回**実行（`--json --paths-only` モード / `-Json -PathsOnly` の組み合わせ）。最小限のJSONペイロードフィールドをパース:
   - `FEATURE_DIR`
   - `FEATURE_SPEC`
   - （オプションで将来の連鎖フロー用に `IMPL_PLAN`、`TASKS` をキャプチャ。）
   - JSONパースが失敗した場合、中止してユーザーに `/speckit.specify` を再実行するか機能ブランチ環境を確認するよう指示。
   - 引数に "I'm Groot" のようなシングルクォートがある場合、エスケープ構文を使用: 例 'I'\''m Groot'（または可能なら二重引用符: "I'm Groot"）。

2. **スタイルガイドを読み込み**: `.specify/README.md` を読み込んで用語集とスタイルガイドを把握。仕様更新時に以下を遵守:
   - セクション見出しには規定の絵文字を使用する
   - 用語対応表に従って一貫した日本語表現を使用する
   - 英語維持する特殊文字列（マーカー、ステータス、ファイル名等）は変換しない

3. 現在の仕様ファイルを読み込む。この分類法を使用して構造化された曖昧さとカバレッジのスキャンを実行。各カテゴリについてステータスをマーク: Clear / Partial / Missing。優先順位付けに使用される内部カバレッジマップを生成（質問が行われない場合を除き、生のマップを出力しない）。

   機能スコープと動作:
   - コアユーザーゴールと成功基準
   - 明示的なスコープ外宣言
   - ユーザーロール/ペルソナの差別化

   ドメインとデータモデル:
   - エンティティ、属性、リレーション
   - アイデンティティと一意性ルール
   - ライフサイクル/状態遷移
   - データ量/スケールの仮定

   インタラクションとUXフロー:
   - 重要なユーザージャーニー/シーケンス
   - エラー/空/ローディング状態
   - アクセシビリティまたはローカライゼーションの注記

   非機能品質属性:
   - パフォーマンス（レイテンシ、スループット目標）
   - スケーラビリティ（水平/垂直、制限）
   - 信頼性と可用性（稼働時間、リカバリー期待）
   - オブザーバビリティ（ロギング、メトリクス、トレーシングシグナル）
   - セキュリティとプライバシー（authN/Z、データ保護、脅威仮定）
   - コンプライアンス/規制制約（ある場合）

   統合と外部依存関係:
   - 外部サービス/APIと失敗モード
   - データインポート/エクスポート形式
   - プロトコル/バージョニングの仮定

   エッジケースと失敗処理:
   - ネガティブシナリオ
   - レート制限/スロットリング
   - 競合解決（例: 同時編集）

   制約とトレードオフ:
   - 技術的制約（言語、ストレージ、ホスティング）
   - 明示的なトレードオフまたは却下された代替案

   用語と一貫性:
   - 正規の用語集用語
   - 避けるべき同義語/非推奨用語

   完了シグナル:
   - 受入基準のテスト可能性
   - 測定可能なDefinition of Doneスタイルの指標

   その他/プレースホルダー:
   - TODOマーカー/未解決の決定
   - 定量化のない曖昧な形容詞（"堅牢"、"直感的"）

   PartialまたはMissingステータスのカテゴリについて、以下の場合を除き候補質問機会を追加:
   - 明確化が実装または検証戦略を実質的に変更しない
   - 情報は計画フェーズに延期した方がよい（内部的にメモ）

4. 候補明確化質問の優先順位付きキューを（内部的に）生成（最大5つ）。一度にすべてを出力しない。以下の制約を適用:
    - セッション全体で最大10の質問。
    - 各質問は以下のいずれかで回答可能である必要がある:
       - 短い選択式の選択（2–5の異なる、相互に排他的なオプション）、または
       - 一言/短いフレーズの回答（明示的に制約: "5語以内で回答"）。
    - アーキテクチャ、データモデリング、タスク分解、テスト設計、UX動作、運用準備、またはコンプライアンス検証に実質的に影響する質問のみを含める。
    - カテゴリカバレッジバランスを確保: 最も影響の高い未解決カテゴリを最初にカバーしようとする; 単一の高影響領域（例: セキュリティ姿勢）が未解決のときに2つの低影響質問を避ける。
    - 既に回答済みの質問、些細なスタイルの好み、または計画レベルの実行詳細（正確性をブロックしない限り）を除外。
    - 下流の手戻りリスクを減らすか、不整合な受入テストを防ぐ明確化を優先。
    - 5つ以上のカテゴリが未解決のままの場合、（影響 * 不確実性）発見的手法で上位5つを選択。

5. 順次質問ループ（インタラクティブ）:
    - 一度に**正確に1つの質問**を提示。
    - 選択式質問の場合:
       - **すべてのオプションを分析**し、以下に基づいて**最も適切なオプション**を決定:
          - プロジェクトタイプのベストプラクティス
          - 類似実装の一般的なパターン
          - リスク低減（セキュリティ、パフォーマンス、保守性）
          - 仕様に見える明示的なプロジェクト目標または制約との整合
       - **推奨オプション**を上部に目立つように提示し、明確な理由付け（1-2文でこれが最良の選択である理由を説明）。
       - 形式: `**推奨:** オプション [X] - <理由>`
       - その後、すべてのオプションをMarkdownテーブルとしてレンダリング:

       | オプション | 説明 |
       |------------|------|
       | A | <オプションAの説明> |
       | B | <オプションBの説明> |
       | C | <オプションCの説明>（必要に応じてD/Eを最大5つまで追加） |
       | Short | 別の短い回答を提供（5語以内）（フリーフォームの代替案が適切な場合のみ含める） |

       - テーブルの後に追加: `オプションの文字で回答できます（例: "A"）、"yes"または"recommended"と言って推奨を受け入れるか、独自の短い回答を提供できます。`
    - 短答式スタイル（意味のある離散オプションがない）の場合:
       - ベストプラクティスとコンテキストに基づいた**提案回答**を提供。
       - 形式: `**提案:** <提案される回答> - <簡潔な理由>`
       - その後出力: `形式: 短い回答（5語以内）。"yes"または"suggested"と言って提案を受け入れるか、独自の回答を提供できます。`
    - ユーザーが回答した後:
       - ユーザーが "yes"、"recommended"、または "suggested" と回答した場合、以前に述べた推奨/提案を回答として使用。
       - そうでなければ、回答が1つのオプションにマッピングされるか、5語以内の制約に適合することを検証。
       - 曖昧な場合、簡単な曖昧さ解消を依頼（カウントは同じ質問に属する; 進まない）。
       - 満足したら、作業メモリに記録（まだディスクには書き込まない）し、次のキューに入れられた質問に進む。
    - 以下の場合、さらなる質問を停止:
       - 重要な曖昧さがすべて早期に解決された（残りのキュー項目が不要になる）、または
       - ユーザーが完了を示す（"done"、"good"、"no more"）、または
       - 5つの質問に達した。
    - 将来のキュー質問を事前に明らかにしない。
    - 開始時に有効な質問が存在しない場合、重大な曖昧さは検出されなかったと直ちに報告。

6. 受け入れられた各回答後の統合（インクリメンタル更新アプローチ）:
    - 仕様のインメモリ表現（開始時に1回読み込み）と生のファイル内容を維持。
    - このセッションで最初に統合された回答について:
       - `## Clarifications` セクションが存在することを確認（欠落している場合は仕様テンプレートに従って最上位のコンテキスト/概要セクションの直後に作成）。
       - その下に `### Session YYYY-MM-DD` サブ見出しを作成（存在しない場合）。
    - 受け入れ直後に箇条書き行を追加: `- Q: <質問> → A: <最終回答>`。
    - その後、最も適切なセクションに明確化を直ちに適用:
       - 機能的曖昧さ → 機能要件の箇条書きを更新または追加。
       - ユーザーインタラクション/アクターの区別 → User StoriesまたはActorsサブセクション（存在する場合）を明確化されたロール、制約、またはシナリオで更新。
       - データ形状/エンティティ → Data Modelを更新（フィールド、タイプ、リレーションを追加）順序を保持; 追加された制約を簡潔にメモ。
       - 非機能制約 → Non-Functional / Quality Attributesセクションに測定可能な基準を追加/修正（曖昧な形容詞をメトリックまたは明示的な目標に変換）。
       - エッジケース/ネガティブフロー → Edge Cases / Error Handlingの下に新しい箇条書きを追加（またはテンプレートがプレースホルダーを提供している場合はそのようなサブセクションを作成）。
       - 用語の競合 → 仕様全体で用語を正規化; 必要な場合のみ `(formerly referred to as "X")` を1回追加してオリジナルを保持。
    - 明確化が以前の曖昧なステートメントを無効にする場合、重複する代わりにそのステートメントを置き換える; 古い矛盾するテキストを残さない。
    - コンテキスト喪失のリスクを最小化するため、各統合後に仕様ファイルを保存（アトミック上書き）。
    - フォーマットを保持: 関係のないセクションを並べ替えない; 見出し階層をそのまま維持。
    - 各挿入された明確化を最小限かつテスト可能に保つ（叙述的ドリフトを避ける）。

6. 検証（各書き込み後と最終パスで実行）:
   - Clarificationsセッションには受け入れられた回答ごとに正確に1つの箇条書きが含まれている（重複なし）。
   - 質問された（受け入れられた）合計 ≤ 5。
   - 更新されたセクションには、新しい回答が解決するはずだった曖昧なプレースホルダーが残っていない。
   - 以前の無効なステートメントが残っていない（削除された今は無効な代替選択をスキャン）。
   - Markdown構造が有効; 許可される新しい見出しのみ: `## Clarifications`、`### Session YYYY-MM-DD`。
   - 用語の一貫性: 更新されたすべてのセクションで同じ正規用語が使用されている。

7. 更新された仕様を `FEATURE_SPEC` に書き戻す。

8. 完了を報告（質問ループ終了または早期終了後）:
   - 質問された回数と回答された回数。
   - 更新された仕様へのパス。
   - 触れたセクション（名前をリスト）。
   - 各分類カテゴリをStatus: Resolved（Partial/Missingだったが対処された）、Deferred（質問クォータを超えるか計画に適している）、Clear（既に十分）、Outstanding（まだPartial/Missingだが低影響）でリストするカバレッジサマリーテーブル。
   - OutstandingまたはDeferredが残っている場合、`/speckit.plan` に進むか、計画後に `/speckit.clarify` を再度実行するかを推奨。
   - 推奨される次のコマンド。

動作ルール:

- 意味のある曖昧さが見つからない場合（または潜在的な質問がすべて低影響）、応答: "正式な明確化に値する重大な曖昧さは検出されませんでした。" そして続行を提案。
- 仕様ファイルが欠落している場合、ユーザーにまず `/speckit.specify` を実行するよう指示（ここで新しい仕様を作成しない）。
- 5つの質問された合計を超えない（単一の質問に対する明確化リトライは新しい質問としてカウントしない）。
- 機能的明確さをブロックしない限り、投機的な技術スタック質問を避ける。
- ユーザーの早期終了シグナルを尊重（"stop"、"done"、"proceed"）。
- 完全なカバレッジのため質問が行われなかった場合、コンパクトなカバレッジサマリー（すべてのカテゴリがClear）を出力し、進行を提案。
- 高影響カテゴリが未解決のままクォータに達した場合、Deferredの下に理由を明示的にフラグ。

優先順位付けのコンテキスト: $ARGUMENTS