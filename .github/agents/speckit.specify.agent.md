---
description: 自然言語の機能説明から機能仕様を作成または更新します。
handoffs: 
  - label: speckit.plan
    agent: speckit.plan
    prompt: 仕様の計画を作成します。使用技術は...
  - label: speckit.clarify
    agent: speckit.clarify
    prompt: 仕様要件を明確化します
    send: true
---

## ユーザー入力

```text
$ARGUMENTS
```

続行する前に、ユーザー入力を考慮する**必要があります**（空でない場合）。

## 概要

ユーザーがトリガーメッセージで `/speckit.specify` の後に入力したテキストが機能説明です。`$ARGUMENTS` が文字通り下に表示されていても、この会話で常に利用可能であると仮定してください。空のコマンドを提供した場合を除き、ユーザーに繰り返すよう依頼しないでください。

その機能説明に基づいて、以下を実行します:

1. **ブランチ用の簡潔な短縮名を生成**（2-4単語）:
   - 機能説明を分析し、最も意味のあるキーワードを抽出
   - 機能の本質を捉える2-4単語の短縮名を作成
   - 可能な場合はアクション-名詞形式を使用（例: "add-user-auth", "fix-payment-bug"）
   - 技術用語と略語を保持（OAuth2, API, JWT など）
   - 一目で機能を理解できる程度に簡潔かつ説明的に
   - 例:
     - "ユーザー認証を追加したい" → "user-auth"
     - "API用のOAuth2統合を実装" → "oauth2-api-integration"
     - "分析用のダッシュボードを作成" → "analytics-dashboard"
     - "支払い処理のタイムアウトバグを修正" → "fix-payment-timeout"

2. **新規作成前に既存ブランチを確認**:

   a. まず、最新情報を確保するためにすべてのリモートブランチをフェッチ:

      ```bash
      git fetch --all --prune
      ```

   b. 短縮名に対するすべてのソースで最大の機能番号を見つける:
      - リモートブランチ: `git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - ローカルブランチ: `git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - Specsディレクトリ: `specs/[0-9]+-<short-name>` に一致するディレクトリを確認

   c. 次に利用可能な番号を決定:
      - 3つのソースすべてから数字を抽出
      - 最大番号Nを見つける
      - 新しいブランチ番号にN+1を使用

   d. 計算された番号と短縮名でスクリプト `.specify/scripts/bash/create-new-feature.sh --json "$ARGUMENTS"` を実行:
      - 機能説明と共に `--number N+1` と `--short-name "your-short-name"` を渡す
      - Bash例: `.specify/scripts/bash/create-new-feature.sh --json --number 5 --short-name "user-auth" "Add user authentication"`
      - PowerShell例: `.specify/scripts/bash/create-new-feature.sh -Json -Number 5 -ShortName "user-auth" "Add user authentication"`

   **重要**:
   - 最大番号を見つけるために3つのソース（リモートブランチ、ローカルブランチ、specsディレクトリ）すべてを確認
   - 正確な短縮名パターンを持つブランチ/ディレクトリのみに一致
   - この短縮名で既存のブランチ/ディレクトリが見つからない場合、番号1から開始
   - 機能ごとにこのスクリプトを1回だけ実行する必要がある
   - JSONはターミナルに出力として提供される - 探しているコンテンツを取得するために常に参照
   - JSON出力にはBRANCH_NAMEとSPEC_FILEパスが含まれる
   - 引数に "I'm Groot" のようなシングルクォートがある場合、エスケープ構文を使用: 例 'I'\''m Groot'（または可能なら二重引用符: "I'm Groot"）

3. `.specify/README.md` を読み込んで用語集とスタイルガイドを把握。
   - セクション見出しには規定の絵文字を使用する
   - 用語対応表に従って一貫した日本語表現を使用する
   - 英語維持する特殊文字列（マーカー、ステータス、ファイル名等）は変換しない

4. `.specify/templates/spec-template.md` を読み込んで必要なセクションを理解。
   - テンプレートには絵文字付きセクション見出し（📋, 👤, 📝, 🎯）と目次が含まれる
   - メタデータはテーブル形式で、入力は別セクション（`## 📥 1. 入力`）として分離されている

5. 以下の実行フローに従う:

    1. 入力からユーザー説明を解析
       空の場合: ERROR "機能説明が提供されていません"
    2. 説明から主要な概念を抽出
       識別: アクター、アクション、データ、制約
    3. 不明確な点について:
       - コンテキストと業界標準に基づいて情報に基づいた推測を行う
       - 以下の場合のみ [NEEDS CLARIFICATION: 具体的な質問] でマーク:
         - 選択が機能スコープやユーザー体験に大きな影響を与える
         - 異なる意味を持つ複数の合理的な解釈が存在する
         - 合理的なデフォルトが存在しない
       - **制限: 最大3つの [NEEDS CLARIFICATION] マーカー**
       - 影響度で明確化の優先順位: スコープ > セキュリティ/プライバシー > ユーザー体験 > 技術詳細
    4. ユーザーシナリオとテストセクションを記入
       明確なユーザーフローがない場合: ERROR "ユーザーシナリオを決定できません"
    5. 機能要件を生成
       各要件はテスト可能である必要がある
       未指定の詳細には合理的なデフォルトを使用（前提条件セクションに仮定を文書化）
    6. 成功基準を定義
       測定可能で技術非依存の成果を作成
       定量的指標（時間、パフォーマンス、量）と定性的指標（ユーザー満足度、タスク完了）の両方を含む
       各基準は実装詳細なしで検証可能である必要がある
    7. 主要エンティティを特定（データが関与する場合）
    8. 戻り値: SUCCESS（計画の準備完了）

6. プレースホルダーを機能説明（引数）から導出された具体的な詳細で置き換えながら、テンプレート構造を使用してSPEC_FILEに仕様を書き込む。セクションの順序と見出しは保持。

   **ユーザーストーリーの見出し形式**:
   - セクション「ユーザーストーリー」内のH3見出しは以下の形式を使用:
     - `### 2.1 US1: [タイトル] [P1]`
     - `### 2.2 US2: [タイトル] [P2]`
     - `### 2.3 US3: [タイトル] [P3]`
   - US = User Storyの略称、tasks.mdの[US1]ラベルと対応
   - [Pn] = 優先度ラベル（P1=必須/MVP, P2=重要, P3=あれば良い）

   **目次の生成ルール**:
   - 目次はH3レベルまで含める（H4は含めない）
   - テンプレートの目次は構造の参考例として使用
   - 実際の仕様作成時は、記述した見出しから動的にアンカーリンクを生成する
   - H3項目は親のH2の下にインデント（2スペース + `-`）で配置
   - アンカーリンク生成ルール（GitHub Markdown仕様）:
     - 絵文字 → `-` に置換
     - ピリオド `.` → 削除
     - スペース → `-` に変換
     - 括弧 `[]()（）` → 削除
     - 大文字 → 小文字に変換
     - 同一アンカーが複数存在する場合 → 2つ目以降に `-1`, `-2` を付与
   - 例: `### 2.1 ユーザー登録` → `[2.1 ユーザー登録](#21-ユーザー登録)`

   **メタデータテーブルの記入**:
   - `[FEATURE NAME]`: 機能説明から導出した機能名
   - `[###-feature-name]`: スクリプトが生成したブランチ名
   - `[DATE]`: 現在の日付（YYYY-MM-DD形式）

   **入力セクションの記入**:
   - `$ARGUMENTS` を実際のユーザー入力で置き換える
   - 長い入力の場合、コメントのヒントに従って整理することを推奨

7. **仕様品質検証**: 初期仕様を書いた後、品質基準に対して検証:

   a. **仕様品質チェックリストを作成**: `.specify/templates/requirements-template.md` を読み込み、テンプレート構造を使用して `FEATURE_DIR/checklists/requirements.md` にチェックリストファイルを生成:
      - `[FEATURE NAME]`: 機能説明から導出した機能名で置き換え
      - `[DATE]`: 現在の日付（YYYY-MM-DD形式）で置き換え
      - `[spec.mdへのリンク]`: 機能の spec.md への相対パスで置き換え

   b. **検証チェックを実行**: 各チェックリスト項目に対して仕様をレビュー:
      - 各項目について合格か不合格かを判断
      - 見つかった具体的な問題を文書化（関連する仕様セクションを引用）

   c. **検証結果の処理**:

      - **すべての項目が合格の場合**: チェックリストを完了としてマークし、ステップ6に進む

      - **項目が不合格の場合（[NEEDS CLARIFICATION] を除く）**:
        1. 不合格の項目と具体的な問題をリスト
        2. 各問題に対処するために仕様を更新
        3. すべての項目が合格するまで検証を再実行（最大3回の反復）
        4. 3回の反復後もまだ不合格の場合、残りの問題をチェックリストのノートに文書化しユーザーに警告

      - **[NEEDS CLARIFICATION] マーカーが残っている場合**:
        1. 仕様からすべての [NEEDS CLARIFICATION: ...] マーカーを抽出
        2. **制限チェック**: 3つ以上のマーカーが存在する場合、最も重要な3つのみを保持（スコープ/セキュリティ/UXの影響度順）し、残りは情報に基づいた推測を行う
        3. 各明確化が必要な項目（最大3つ）について、以下の形式でユーザーにオプションを提示:

           ```markdown
           ## 質問 [N]: [トピック]
           
           **コンテキスト**: [関連する仕様セクションを引用]
           
           **知る必要があること**: [NEEDS CLARIFICATIONマーカーからの具体的な質問]
           
           **推奨回答**:
           
           | オプション | 回答 | 影響 |
           |--------|--------|--------------|
           | A      | [最初の推奨回答] | [機能への影響] |
           | B      | [2番目の推奨回答] | [機能への影響] |
           | C      | [3番目の推奨回答] | [機能への影響] |
           | カスタム | 独自の回答を提供 | [カスタム入力の提供方法を説明] |
           
           **選択**: _[ユーザーの応答を待つ]_
           ```

        4. **重要 - テーブルフォーマット**: マークダウンテーブルが正しくフォーマットされていることを確認:
           - パイプを揃えて一貫したスペーシング
           - 各セルはコンテンツの周りにスペースがある: `| コンテンツ |` であり `|コンテンツ|` ではない
           - ヘッダー区切りは少なくとも3つのダッシュが必要: `|--------|`
           - テーブルがマークダウンプレビューで正しくレンダリングされることをテスト
        5. 質問に連続番号を付ける（Q1, Q2, Q3 - 最大3つ）
        6. 応答を待つ前にすべての質問を一緒に提示
        7. ユーザーがすべての質問に対する選択で応答するのを待つ（例: "Q1: A, Q2: カスタム - [詳細], Q3: B"）
        8. 各 [NEEDS CLARIFICATION] マーカーをユーザーが選択または提供した回答で置き換えて仕様を更新
        9. すべての明確化が解決された後に検証を再実行

   d. **チェックリストを更新**: 各検証反復の後、現在の合格/不合格ステータスでチェックリストファイルを更新

7. ブランチ名、仕様ファイルパス、チェックリスト結果、次のフェーズ（`/speckit.clarify` または `/speckit.plan`）の準備状況で完了を報告。

**注意:** スクリプトは新しいブランチを作成してチェックアウトし、書き込む前に仕様ファイルを初期化します。

## 一般的なガイドライン

## クイックガイドライン

- ユーザーが**何を**必要とし**なぜ**かに焦点を当てる。
- 実装方法を避ける（技術スタック、API、コード構造なし）。
- 開発者ではなくビジネスステークホルダー向けに記述。
- 仕様に埋め込まれたチェックリストは作成しない。それは別のコマンドになります。

### セクション要件

- **必須セクション**: すべての機能で完了する必要がある
- **オプションセクション**: 機能に関連する場合のみ含める
- セクションが適用されない場合、完全に削除（「N/A」のままにしない）

### AI生成用

ユーザープロンプトからこの仕様を作成する際:

1. **情報に基づいた推測を行う**: ギャップを埋めるためにコンテキスト、業界標準、一般的なパターンを使用
2. **仮定を文書化**: 前提条件セクションに合理的なデフォルトを記録
3. **明確化を制限**: 最大3つの [NEEDS CLARIFICATION] マーカー - 以下の重要な決定にのみ使用:
   - 機能スコープやユーザー体験に大きな影響を与える
   - 異なる意味を持つ複数の合理的な解釈がある
   - 合理的なデフォルトがない
4. **明確化の優先順位**: スコープ > セキュリティ/プライバシー > ユーザー体験 > 技術詳細
5. **テスターのように考える**: すべての曖昧な要件は「テスト可能で曖昧でない」チェックリスト項目で不合格になるべき
6. **明確化が必要な一般的な領域**（合理的なデフォルトがない場合のみ）:
   - 機能のスコープと境界（特定のユースケースを含める/除外する）
   - ユーザータイプと権限（複数の矛盾する解釈が可能な場合）
   - セキュリティ/コンプライアンス要件（法的/財務的に重要な場合）

**合理的なデフォルトの例**（これらについては質問しない）:

- データ保持: ドメインの業界標準プラクティス
- パフォーマンス目標: 指定されない限り標準的なWeb/モバイルアプリの期待
- エラー処理: 適切なフォールバックを持つユーザーフレンドリーなメッセージ
- 認証方法: Webアプリの標準的なセッションベースまたはOAuth2
- 統合パターン: 指定されない限りRESTful API

### 成功基準ガイドライン

成功基準は以下である必要がある:

1. **測定可能**: 特定の指標を含む（時間、パーセンテージ、数、率）
2. **技術非依存**: フレームワーク、言語、データベース、ツールへの言及なし
3. **ユーザー中心**: システム内部ではなくユーザー/ビジネスの観点から成果を記述
4. **検証可能**: 実装詳細を知らなくてもテスト/検証可能

**良い例**:

- "ユーザーは3分以内にチェックアウトを完了できる"
- "システムは10,000の同時ユーザーをサポート"
- "検索の95%が1秒以内に結果を返す"
- "タスク完了率が40%向上"

**悪い例**（実装中心）:

- "APIレスポンスタイムが200ms未満"（技術的すぎる、"ユーザーは即座に結果を見る"を使用）
- "データベースが1000 TPSを処理できる"（実装詳細、ユーザー向け指標を使用）
- "Reactコンポーネントが効率的にレンダリング"（フレームワーク固有）
- "Redisキャッシュヒット率が80%以上"（技術固有）
